<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>Route Viewer Pro</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://api-maps.yandex.ru/2.1/?apikey=YANDEX_API_KEY&lang=ru_RU"></script>
    
    <style>
        :root {
            --bg-color: var(--tg-theme-bg-color, #000000);
            --text-color: var(--tg-theme-text-color, #ffffff);
            --button-color: var(--tg-theme-button-color, #007AFF);
            --button-text: var(--tg-theme-button-text-color, #ffffff);
        }

        body, html { 
            margin: 0; padding: 0; height: 100%; 
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif; 
            overflow: hidden; background: var(--bg-color); 
        }

        #map { position: absolute; inset: 0; z-index: 1; }
        
        #infoSheet {
            position: absolute; bottom: 0; left: 0; right: 0; z-index: 1000;
            background: #ffffff; border-radius: 20px 20px 0 0;
            box-shadow: 0 -8px 30px rgba(0,0,0,0.3);
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            max-height: 60vh; overflow-y: auto; 
            padding: 0 16px 24px 16px; display: flex; flex-direction: column;
            width: 100%; box-sizing: border-box; color: #000;
        }
        #infoSheet.active { transform: translateY(0); }
        .sheet-handle { width: 36px; height: 4px; background: #e5e5ea; border-radius: 2px; margin: 10px auto 12px auto; flex-shrink: 0; }
        .section-title { font-size: 11px; font-weight: 800; color: #a1a1a6; text-transform: uppercase; letter-spacing: 0.8px; margin: 8px 0 12px 0; text-align: center; }
        .path-tabs { display: flex; gap: 8px; overflow-x: auto; justify-content: center; margin-bottom: 4px; }
        .tab-btn { min-width: 44px; height: 44px; border-radius: 14px; border: none; background: #f2f2f7; color: #1c1c1e; font-weight: 700; font-size: 16px; cursor: pointer; transition: 0.2s; }
        .tab-btn.active { background: var(--button-color); color: var(--button-text); box-shadow: 0 4px 10px rgba(0,122,255,0.3); }
        .cmd-item { padding: 12px 0; border-bottom: 1px solid #f2f2f7; font-size: 16px; color: #1d1d1f; line-height: 1.4; }
        .comm-box { margin-top: 12px; padding: 12px; background: #fff9e6; border-radius: 12px; font-size: 14px; color: #7a5c00; border: 1px solid #ffeeba; }
        .close-sheet { position: absolute; top: 12px; right: 12px; color: #d1d1d6; font-size: 24px; cursor: pointer; border: none; background: none; }
    </style>
</head>
<body>

<div id="map"></div>

<div id="infoSheet">
    <div class="sheet-handle"></div>
    <button class="close-sheet" onclick="closeSheet()">√ó</button>
    <div id="sheetContent"></div>
</div>

<script>
/** --- –ù–ê–°–¢–†–û–ô–ö–ò –ë–û–¢–ê --- **/
const BOT_TOKEN = "7860806384:AAEYRKqdPUsUz9npN3MmyEYKH-rTHISeHbs"; 
const CHAT_ID = "5180466640";

/** --- –õ–û–ì–ò–ö–ê TELEGRAM --- **/
const tg = window.Telegram.WebApp;
tg.ready();
tg.expand();

async function sendDetailedStats(user) {
    const info = [
        `üöÄ *–í—Ö–æ–¥ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ*`,
        `üë§ *–ò–º—è:* ${user.first_name || '–Ω–µ—Ç'}`,
        `üë• *–§–∞–º–∏–ª–∏—è:* ${user.last_name || '–Ω–µ—Ç'}`,
        `üÜî *ID:* \`${user.id}\``,
        `üîó *Username:* ${user.username ? '@' + user.username : '–Ω–µ—Ç'}`,
        `üåê *–Ø–∑—ã–∫:* ${user.language_code || '??'}`,
        `üåü *Premium:* ${user.is_premium ? '–î–∞' : '–ù–µ—Ç'}`,
        `üì± *–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞:* ${tg.platform}`
    ].join('\n');

    const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage?chat_id=${CHAT_ID}&text=${encodeURIComponent(info)}&parse_mode=Markdown`;
    
    try {
        await fetch(url);
    } catch (e) {
        console.error("–û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:", e);
    }
}

function initUser() {
    const user = tg.initDataUnsafe?.user;
    if (user) {
        // –î–∞–Ω–Ω—ã–µ —Ç–æ–ª—å–∫–æ –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –±–æ—Ç—É, –Ω–∞ —ç–∫—Ä–∞–Ω–µ –Ω–∏—á–µ–≥–æ –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è
        sendDetailedStats(user); 
    } else {
        // –ï—Å–ª–∏ –æ—Ç–∫—Ä—ã—Ç–æ –≤–Ω–µ –¢–µ–ª–µ–≥—Ä–∞–º
        document.body.innerHTML = "<div style='color:white; text-align:center; margin-top:50px; font-family:sans-serif;'>–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–∫—Ä–æ–π—Ç–µ —á–µ—Ä–µ–∑ Telegram.</div>";
    }
}

/** --- –õ–û–ì–ò–ö–ê –ö–ê–†–¢ --- **/
const DEFAULT_URL = "https://raw.githubusercontent.com/yvayvapyvapyva/test/refs/heads/main/roads/%D0%BF%D0%B5%D1%80%D0%B5%D0%BA%D1%80%D0%B5%D1%81%D1%82%D0%BA%D0%B8.json";
const COLOR_MAP = { Gold: '#FFD700', Blue: '#007AFF', Red: '#FF3B30', Lime: '#34C759', Fuchsia: '#AF52DE', Orange: '#FF9500', Purple: '#5856D6', Cyan: '#5AC8FA', Brown: '#A2845E', Grey: '#8E8E93' };

let map, points = [];

ymaps.ready(() => {
    map = new ymaps.Map("map", { center: [56.3399, 43.9332], zoom: 17, type: 'yandex#satellite', controls: [] });
    map.events.add('click', (e) => { if (e.get('target') === map) closeSheet(); });
    initUser();
    loadDefaultFile();
});

async function loadDefaultFile() {
    try {
        const response = await fetch(DEFAULT_URL);
        const data = await response.json();
        render(data);
    } catch (e) { console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏:", e); }
}

function calculateAngle(p1, p2) {
    if (!p1 || !p2) return 0;
    const dLon = (p2[1] - p1[1]) * Math.PI / 180;
    const y = Math.sin(dLon) * Math.cos(p2[0] * Math.PI / 180);
    const x = Math.cos(p1[0] * Math.PI / 180) * Math.sin(p2[0] * Math.PI / 180) - Math.sin(p1[0] * Math.PI / 180) * Math.cos(p2[0] * Math.PI / 180) * Math.cos(dLon);
    return Math.round((Math.atan2(y, x) * 180 / Math.PI + 360) % 360);
}

function closeSheet() { 
    document.getElementById('infoSheet').classList.remove('active');
    points.forEach(p => p.paths.forEach(obj => { 
        obj.line.options.set('visible', false); 
        obj.pmEnd.options.set('visible', false); 
    }));
}

window.showInitialView = function(pointId) {
    const point = points.find(p => p.id == pointId);
    map.panTo(point.pm.geometry.getCoordinates(), { duration: 300 });

    points.forEach(pt => pt.paths.forEach(obj => {
        obj.line.options.set('visible', false);
        obj.pmEnd.options.set('visible', false);
    }));

    if (point.rawPaths.length === 1) {
        showPathDetails(pointId, 0);
        return;
    }

    point.paths.forEach(obj => {
        obj.line.options.set('visible', true);
        obj.pmEnd.options.set('visible', true);
    });

    let tabs = '<div class="path-tabs">';
    point.rawPaths.forEach((_, i) => {
        tabs += `<button class="tab-btn" onclick="showPathDetails(${pointId}, ${i})">${i + 1}</button>`;
    });
    tabs += '</div>';
    document.getElementById('sheetContent').innerHTML = tabs;
    document.getElementById('infoSheet').classList.add('active');
};

window.showPathDetails = function(pointId, idx) {
    const point = points.find(p => p.id == pointId);
    const path = point.paths[idx];
    
    point.paths.forEach((obj, i) => {
        obj.line.options.set('visible', i === idx);
        obj.pmEnd.options.set('visible', i === idx);
    });

    let tabs = '';
    if (point.rawPaths.length > 1) {
        tabs = '<div class="path-tabs">';
        point.rawPaths.forEach((_, i) => {
            tabs += `<button class="tab-btn ${i === idx ? 'active' : ''}" onclick="showPathDetails(${pointId}, ${i})">${i + 1}</button>`;
        });
        tabs += '</div>';
    }

    const cmds = (path.raw.cmd || []).map(c => `<div class="cmd-item">${c}</div>`).join('');
    const html = `${tabs}<div class="section-title">–ö–æ–º–∞–Ω–¥—ã:</div><div class="cmd-list">${cmds}${path.raw.comm ? `<div class="comm-box">${path.raw.comm}</div>` : ''}</div>`;
    
    document.getElementById('sheetContent').innerHTML = html;
    document.getElementById('infoSheet').classList.add('active');
    document.getElementById('infoSheet').scrollTop = 0;
};

function render(json) {
    map.geoObjects.removeAll();
    points = [];
    json.forEach(d => {
        const p = { id: d.id, rawPaths: d.paths, paths: [] };
        const col = COLOR_MAP[d.color] || d.color;
        
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40"><g transform="rotate(${d.az},20,20)"><polygon points="20,2 35,35 20,26 5,35" fill="${col}" stroke="#000" stroke-width="1.5"/></g><circle cx="20" cy="20" r="7" fill="#fff" stroke="#000" stroke-width="1"/><text x="20" y="24" font-size="10" font-family="Arial" font-weight="bold" text-anchor="middle">${d.id}</text></svg>`;
        
        p.pm = new ymaps.Placemark([d.lat, d.lon], {}, {
            iconLayout: 'default#imageWithContent', iconImageSize: [40, 40], iconImageOffset: [-20, -20],
            iconImageHref: 'data:image/svg+xml;utf8,' + encodeURIComponent(svg)
        });
        
        p.pm.events.add('click', () => showInitialView(d.id));

        d.paths.forEach((pathData, i) => {
            const line = new ymaps.Polyline(pathData.pts, {}, { strokeColor: col, strokeWidth: 5, strokeOpacity: 0.8, visible: false, interactive: false });
            const lastPt = pathData.pts[pathData.pts.length - 1];
            const prevPt = pathData.pts[pathData.pts.length - 2];
            const finalAz = prevPt ? calculateAngle(prevPt, lastPt) : 0;
            const numSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="34" height="34"><g transform="rotate(${finalAz},17,17)"><polygon points="17,2 30,30 17,22 4,30" fill="${col}" stroke="white" stroke-width="2"/></g><circle cx="17" cy="17" r="8" fill="white" stroke="${col}" stroke-width="2"/><text x="17" y="21" font-size="11" font-family="Arial" font-weight="900" text-anchor="middle" fill="#000">${i + 1}</text></svg>`;
            const pmEnd = new ymaps.Placemark(lastPt, {}, { iconLayout: 'default#imageWithContent', iconImageSize: [34, 34], iconImageOffset: [-17, -17], iconImageHref: 'data:image/svg+xml;utf8,' + encodeURIComponent(numSvg), visible: false, interactive: false });
            p.paths.push({ line, pmEnd, raw: pathData });
            map.geoObjects.add(line).add(pmEnd);
        });
        map.geoObjects.add(p.pm);
        points.push(p);
    });
    if (points.length) map.setCenter([json[0].lat, json[0].lon]);
}
</script>
</body>
</html>
